%\section{Approach}
%\label{sec：approach}

\section{SQL Query Approximation}
\label{sec: SQL Query Approximation}

%A fundamental challenge in DBMS testing lies in the test oracle problem:  given two semantically related SQL queries, it is often unclear whether their outputs should be identical or follow a predictable metamorphic relationship.
Traditional testing frameworks typically rely on strict equivalence or simple set inclusion checks, which are insufficient to capture subtle semantic deviations introduced by optimizer transformations or operator mutations~\cite{hao2023pinolo}.  
To address this limitation, we introduce a more comprehensive notion of SQL Query Approximation,  which unifies two complementary perspectives of query behavior: the \textbf{set-semantic} and \textbf{value-semantic} dimensions.  
The set-semantic dimension characterizes differences in the returned tuple sets, while the value-semantic dimension captures monotonic variations in the computed or aggregated values over those tuples.  
Together, these two dimensions form a unified framework for expressing and reasoning about semantic consistency, enabling the construction of more expressive test oracles that can detect both structural and value-level inconsistencies in DBMS behavior.

\subsection{Set-Semantic Approximation}

In this section, we first formalize the notion of approximation at the set level.  
This relation captures inclusion or containment among query result sets.

\begin{definition}[Set-Semantic Approximation Relation]
	\label{def:set_approximation}
	
	Given a database \( D \), let \( q_1 \) and \( q_2 \) be two SQL queries whose result sets are \( R(q_1, D) \) and \( R(q_2, D) \), respectively.  
	We say that \( q_1 \) is the \textit{set-level under-approximation} of \( q_2 \) over \( D \), denoted by  
	\( q_1 \preceq_D^s q_2 \), if and only if:
	\[
	R(q_1, D) \subseteq R(q_2, D)
	\]
	Conversely, \( q_1 \) is the \textit{set-level over-approximation} of \( q_2 \) over \( D \), denoted by  
	\( q_1 \succeq_D^s q_2 \), if and only if:
	\[
	R(q_1, D) \supseteq R(q_2, D)
	\]
	Here, \( R(q, D) \) represents the multi-set returned by evaluating query \( q \) on database \( D \),  
	and \( \subseteq \) and \( \supseteq \) denote inclusion and containment relations between two multi-sets.
\end{definition}


Intuitively, the set-semantic approximation forms a partial order over queries:  
\( q_1 \preceq_D^s q_2 \) means that \( q_1 \) produces a narrower or more restrictive result than \( q_2 \),  
while \( q_1 \succeq_D^s q_2 \) means that \( q_1 \) yields a broader or less restrictive result.  
These two relations are inverses of each other and together define the lattice of set-level approximations.


\begin{example}
	Consider a database \( D = \{t_1\} \), where \( t_1(c_1) = \{-1, 0, 1\} \).  
	Let the following queries be defined:
	\[
	q_1 : \text{\textbf{SELECT} } c_1 \text{ \textbf{FROM} } t_1 \text{ \textbf{WHERE} } c_1 \le 0
	\]
	\[
	q_2 : \text{\textbf{SELECT} } c_1 \text{ \textbf{FROM} } t_1 \text{\textbf{ WHERE} \textbf{TRUE}}
	\]
	\[
	q_3 : \text{\textbf{SELECT} } c_1 \text{ \textbf{FROM}} t_1 \text{ \textbf{WHERE} } c_1 < 0
	\]
	We have:
	\[
	R(q_3, D) = \{-1\}, \quad R(q_1, D) = \{-1, 0\}, \quad R(q_2, D) = \{-1, 0, 1\}
	\]
	Hence,
	\[
	R(q_3, D) \subseteq R(q_1, D) \subseteq R(q_2, D)
	\]
	which gives the approximation chain:
	\[
	q_3 \preceq_D^s q_1 \preceq_D^s q_2
	\]
	Intuitively, \( q_3 \) is a stricter version of \( q_1 \), and \( q_1 \) a stricter version of \( q_2 \),
	each progressively expanding the selection condition and thus broadening the result set.
\end{example}

\subsection{Value-Semantic Approximation}

To overcome the limitation of purely set-level inclusion, we extend the approximation relation from the result-set level to the value level. 
Unlike the set-level relation that focuses on tuple inclusion, the value-semantic relation captures the monotonic variation of target columns — the columns whose values are directly affected by functional or aggregation operations.  
This allows the framework to detect logical bugs where queries return identical tuples but diverge in their value semantics, such as incorrect computations in aggregation or updates.

\begin{definition}[Value-Semantic Approximation Relation]
	\label{def:value_approximation}
	Given a database \( D \), let \( q_1 \) and \( q_2 \) be two SQL queries whose result sets are 
	\( R(q_1, D) \) and \( R(q_2, D) \), respectively.  
	Let \( C_t \subseteq \text{Cols}(R(q_1, D)) \cap \text{Cols}(R(q_2, D)) \) denote the target columns
	whose values will be compared.  
	Let \( G \) denote the grouping or ordering basis, determined as follows:
	
	If the query contains a \texttt{GROUP BY} clause, \( G \) corresponds to the group-by keys.
	Otherwise, \( G \) represents a deterministic ordering over non-target columns 
	(e.g., primary key or lexicographic ordering of attributes) to align tuples for comparison.
	
	We say that \( q_1 \) is the \textit{value-level over-approximation} of \( q_2 \) over \( D \), denoted by 
	\( q_1 \succeq_D^v q_2 \), if and only if:
	\[
	\forall g \in G^*, \forall c \in C_t, \;
	V_{q_1}(g, c) \ge V_{q_2}(g, c)
	\]
	where \( G^* \) is the set of all comparable tuple groups under \( G \),  
	and \( V_q(g, c) \) denotes the value of column \( c \) in group \( g \) (or tuple position) 
	produced by query \( q \).
	
	Conversely, \( q_1 \) is the \textit{value-level under-approximation} of \( q_2 \), denoted by 
	\( q_1 \preceq_D^v q_2 \), if and only if:
	\[
	\forall g \in G^*, \forall c \in C_t, \;
	V_{q_1}(g, c) \le V_{q_2}(g, c)
	\]
	This definition unifies two cases: group-wise comparison for aggregation queries, 
	and order-aligned comparison for non-aggregated results.
\end{definition}


\noindent
Intuitively, the \textit{set-semantic approximation} (\( \preceq_D^s \)) describes inclusion of tuples,  
while the \textit{value-semantic approximation} (\( \preceq_D^v \)) 
reflects monotonicity among the values of corresponding tuples.  
%\lin{Check why can coexist?}
%In practice, the two forms often coexist:
%\[
%q_1 \preceq_D^s q_2 \;\wedge\; q_1 \preceq_D^v q_2
%\]
%which indicates that \( q_1 \) returns a subset of \( q_2 \)’s tuples 
%and the corresponding values in the target columns are not larger.

\begin{example}
	Consider a table \( t_1(c_1, c_2) \) as follows:
	\[
	t_1 =
	\begin{array}{c|c}
		c_2 & c_1 \\
		\hline
		A & 10 \\
		A & 20 \\
		B & 5 \\
		B & 7
	\end{array}
	\]
	Let the following two queries be defined:
	\[
	q_1 : \text{\textbf{SELECT} } c_2, \text{ MAX}(c_1) 
	\text{ \textbf{FROM} } t_1 \text{ \textbf{GROUP BY} } c_2
	\]
	\[
	q_2 : \text{\textbf{SELECT} } c_2, \text{ MIN}(c_1) 
	\text{ \textbf{FROM} } t_1 \text{ \textbf{GROUP BY} } c_2
	\]
	The results are:
	\[
	R(q_1, D) =
	\begin{array}{c|c}
		c_2 & \text{MAX}(c_1) \\
		\hline
		A & 20 \\
		B & 7
	\end{array}
	\quad
	R(q_2, D) =
	\begin{array}{c|c}
		c_2 & \text{MIN}(c_1) \\
		\hline
		A & 10 \\
		B & 5
	\end{array}
	\]
	Under the grouping basis \( G = \{c_2\} \) and target column \( C_t = \{c_1\} \),
	we have for each \( g \in G^* = \{\text{A}, \text{B}\} \):
	\[
	V_{q_1}(g, c_1) \ge V_{q_2}(g, c_1)
	\]
	Hence, \( q_1 \succeq_D^v q_2 \).  
	Intuitively, both queries return identical group sets (thus \( q_1 \equiv_D^s q_2 \)), 
	but differ monotonically in their value semantics:  
	the aggregated value of \( q_1 \) in each group is no smaller than that of \( q_2 \).
\end{example}

\subsection{Approximation Propagation}

The approximation relations introduced in the previous section capture the semantic correspondence between two complete SQL queries by comparing their result sets or value outputs.  
However, in practical DBMS testing, a mutation usually affects only a local part of the query---for instance, 
a predicate, an operator, or an aggregation function---rather than the entire query.  
To understand how such a local change influences the final query result, we extend the discussion from the semantic level of full-query comparison to the structural level of SQL.  
Specifically, we define the concept of \textit{approximation propagation}, 
which describes how a local approximation relation established at one node of the query’s abstract syntax tree (AST)
can be transmitted through its parent operators and clauses, 
thereby determining how a single mutation impacts the overall approximation behavior of the query.


\begin{definition}[Approximation Propagation]
	\label{def:approximation_propagation}
	
	Let \( D \) be a database, and let \( n_1, n_2 \) denote two semantically comparable
	nodes (e.g., subqueries, predicates, or expressions) in the SQL AST.
	We use the unified notation \( n_1 \preceq_D^\alpha n_2 \)
	to represent an \textit{approximation relation} of type \( \alpha \in \{s, v\} \),
	where \( s \) and \( v \) correspond to the set-semantic and value-semantic levels, respectively.
	The relations defined in \S\ref{def:set_approximation} and \S\ref{def:value_approximation}
	describe query-level approximations between complete queries.
	In contrast, approximation propagation extends these relations to the structural level,
	capturing how local approximations between AST nodes can influence or induce
	approximations at higher layers of the query.
	
%	Formally, let \( \sigma(op) \in \{+1, -1\} \) denote the \textit{monotonic direction} of an operator \( op \):
%	\(+1\) means the operator preserves the approximation direction (monotone increasing),
%	while \(-1\) means it reverses the direction (monotone decreasing or negating).
%	Then, the propagation of \( n_1 \preceq_D^\alpha n_2 \) follows the four canonical forms:

	Formally, each operator \( op \) is characterized by two semantic properties: a \textit{mapping} \((\alpha_{in} \!\rightarrow\! \alpha_{out})\), which specifies how the operator transforms between set-level and value-level semantics, and a \textit{direction} \(\sigma(op)\!\in\!\{+1, -1\}\), where \(+1\) indicates that the operator preserves the approximation direction (monotone increasing) and \(-1\) indicates that it reverses the direction (monotone decreasing or negating). 
	Based on these properties, the propagation of \( n_1 \preceq_D^\alpha n_2 \) can be classified into four canonical forms:

	\begin{itemize}[leftmargin=10pt]
		
		\item \textbf{(Set $\rightarrow$ Set)}:
		If a subquery or predicate \( p_1 \preceq_D^s p_2 \) is embedded under a higher-level
		set operator \( op_s \) (e.g., \texttt{EXISTS}, \texttt{NOT EXISTS}, logical \texttt{NOT}),
		then the resulting relation satisfies:
		\[
		R(n_1, D) \preceq_D^{s \cdot \sigma(op_s)} R(n_2, D)
		\]
		where operators such as \texttt{EXISTS} are monotone increasing (\( \sigma=+1 \)),
		while \texttt{NOT EXISTS} or \texttt{NOT} are monotone decreasing (\( \sigma=-1 \)),
		reversing inclusion (\( \subseteq \leftrightarrow \supseteq \)).
		
		\item \textbf{(Set $\rightarrow$ Value)}:
		If an aggregation or mapping function \( f \) is applied to two relations
		that satisfy \( R(n_1, D) \preceq_D^s R(n_2, D) \),
		then the corresponding value-level results satisfy:
		\[
		f(R(n_1, D)) \preceq_D^{v \cdot \sigma(f)} f(R(n_2, D))
		\]
		where \( \sigma(f)=+1 \) for monotone-increasing functions
		(e.g., \texttt{MAX}, \texttt{SUM}, \texttt{COUNT}),
		and \( \sigma(f)=-1 \) for monotone-decreasing ones (e.g., \texttt{MIN}).
		
		\item \textbf{(Value $\rightarrow$ Value)}:
		If an expression or scalar operator \( op_v \) is transformed to another form
		with monotonic direction \( \sigma(op_v) \),
		then the resulting value-level outputs satisfy:
		\[
		V_{n_1}(g, c) \preceq_D^{v \cdot \sigma(op_v)} V_{n_2}(g, c)
		\]
		This covers arithmetic transformations (\texttt{+}, \texttt{*2} with \(c>0\)) and functional ones (\texttt{MAX}$\rightarrow$\texttt{MIN}).
		
		\item \textbf{(Value $\rightarrow$ Set)}:
		If a value expression \( V_{n} \) feeds into a predicate or filtering operator \( op_s \),
		and \( V_{n_1} \preceq_D^v V_{n_2} \),
		then the induced output relations satisfy:
		\[
		R(n_1, D) \preceq_D^{s \cdot \sigma(op_s)} R(n_2, D)
		\]
		where \( \sigma(op_s)=+1 \) for monotone-increasing predicates
		(e.g., \texttt{x > c}, where larger values of \texttt{x} make the condition more likely to hold and thus expand the result set),
		and \( \sigma(op_s)=-1 \) for monotone-decreasing ones
		(e.g., \texttt{x < c} or \texttt{NOT EXISTS}, where larger values of \texttt{x} make the condition less likely to hold, causing the result set to shrink).
		
		
	\end{itemize}
\end{definition}

\noindent
\textbf{Remark.}
In this definition, \( n_1 \) and \( n_2 \) are not restricted to complete queries.
They can represent corresponding subqueries, expressions, or predicates
within a single query or across two query variants.
The relation \( \preceq_D^\alpha \) thus captures how a local semantic approximation
propagates through SQL operators according to their monotonic behavior,
bridging the value- and set-level semantics within the same unified framework.

Intuitively, the propagation mechanism provides the semantic bridge between 
\textit{tuple-level inclusion} and \textit{value-level monotonicity}.
Set-level approximations can trigger value changes through monotone o perators,
while value level changes can, in turn, alter the query result set when the affected values participate in predicates.
This bidirectional propagation enables comprehensive reasoning over multi-layer SQL dependencies.


\begin{example}[Set $\rightarrow$ Value Propagation]
	Consider two queries over a table \( t_1(c_1, c_2) \):
	\[
	q_1 : \textbf{SELECT MAX}(c_1) \textbf{ FROM } t_1 \textbf{ WHERE } c_2 < 100
	\]
	\[
	q_2 : \textbf{SELECT MAX}(c_1) \textbf{ FROM } t_1 \textbf{ WHERE } c_2 < 200
	\]
	
	In the query structure, let \( n_1 \) and \( n_2 \) denote the \texttt{WHERE} clause nodes of 
	\( q_1 \) and \( q_2 \), respectively.
	The condition \( c_2 < 100 \) in \( n_1 \) is stricter than \( c_2 < 200 \) in \( n_2 \),
	so the rows selected by \( n_1 \) form a subset of those selected by \( n_2 \).
	The parent node of these filters is the aggregation operator \texttt{MAX},
	which is monotone increasing:
	when more rows are included, the maximum value of \( c_1 \) can only increase or remain the same.
	As a result, the difference at the set level (fewer or more tuples)
	propagates upward to a difference at the value level (smaller or larger aggregated value).
	
	Intuitively, \( n_1 \) and \( n_2 \) illustrate how a local change in the filter condition
	at the set level can influence the aggregated result value, demonstrating the propagation from Set to Value.
\end{example}


\begin{example}[Value $\rightarrow$ Set Propagation]
	Consider two semantically related queries over a table \( t_1(c_1) \):
	\[
	\begin{aligned}
		q_1 : &\; \textbf{SELECT} * \textbf{ FROM } 
		(\textbf{SELECT MAX}(c_1) \textbf{ AS } x \\ 
		&\textbf{FROM } t_1) \textbf{ AS } subq 
		\textbf{ WHERE } x > 100
	\end{aligned}
	\]
	
	\[
	\begin{aligned}
		q_2 : &\; \textbf{SELECT} * \textbf{ FROM } 
		(\textbf{SELECT MIN}(c_1) \textbf{ AS } x \\ 
		&\textbf{FROM } t_1) \textbf{ AS } subq 
		\textbf{ WHERE } x > 100
	\end{aligned}
	\]
	
	The two queries differ only in the inner aggregation.
	Let \( n_1 \) and \( n_2 \) denote the aggregation nodes 
	\texttt{MAX}(c\_1) and \texttt{MIN}(c\_1), respectively.
	Changing \texttt{MAX} to \texttt{MIN} decreases the derived value \( x \).
	Since the outer predicate \texttt{x > 100} is monotone increasing in \( x \),
	smaller \( x \) values make the condition harder to satisfy,
	resulting in fewer output tuples.
	Consequently, the result of \( q_2 \) becomes a subset of \( q_1 \),
	showing a typical Value $\rightarrow$ Set propagation.
\end{example}


These propagation behaviors connect the two approximation dimensions,
allowing a single mutation at any AST node (e.g., \texttt{MAX}$\rightarrow$\texttt{MIN})
to yield predictable, analyzable effects on both result structure and result values.
The unified propagation model forms the semantic foundation of our testing framework.

\section{Approach}

\subsection{Overview}

\begin{figure*}[t]
	\centering
	\includegraphics[width=1\linewidth]{./images/Overview.pdf} 
	\vspace{-8mm}
	\caption{\textbf{Overview of our approach.}}
	\label{fig:overview}
%	\vspace{-2mm}
\end{figure*}

We illustrate the overall workflow of our approach in Figure~\ref{fig:overview}. 
The entire process follows a generate–mutate–verify paradigm designed to uncover logic bugs in DBMSs. 
In the pre-processing phase, we randomly populate multiple tables in a test database, following standard DBMS random testing practices~\cite{rigger2020testing}. 
This randomized setup provides a diverse and unbiased data distribution for subsequent query evaluations.
Next, our system generates a syntactically valid SQL query that serves as the original query. 
It then parses the query and traverses its AST to identify which grammatical constructs can be safely mutated. 
Based on the SQL query approximation models defined in Section~\ref{sec: SQL Query Approximation}, the system automatically synthesizes several approximate queries by mutating the original queries.
After the mutated queries are constructed, the framework performs approximation propagation analysis to reason how local semantic changes at the mutated node propagate through the SQL AST. 
This analysis establishes the global query-level approximation relation (either at the set level or the value level) between the original and mutated queries. 
Finally, both queries are executed on the tested DBMS instance, and their outputs are compared against the predicted approximation relation. 
Any violation of this expected relation indicates a potential logical inconsistency in the DBMS.

In the following sections, we introduce each core component in detail, including the construction of the original query (Section \ref{subsec:Construction of the Original Query}), the design of approximate mutators (Section \ref{subsec:Approximate Mutators}), the propagation algorithm (Section \ref{subsec:Approximation Propagation Analysis}), and the result checking procedure (Section \ref{subsec:Results Checking}).

\subsection{Construction of the Original Query}
\label{subsec:Construction of the Original Query}

To support diverse SQL structures in testing, our framework constructs original queries based on a compact yet expressive SQL grammar, as illustrated in Figure~\ref{fig:sql-bnf-compact}.  
This grammar extends the baseline adopted in \textsc{Pinolo}~\cite{hao2023pinolo} by incorporating a richer set of syntactic components, enabling the generation of more varied queries.  
Compared with \textsc{Pinolo}, which mainly focuses on basic \texttt{SELECT--FROM--WHERE} statements, our implementation supports a broader range of SQL features, including comprehensive \texttt{JOIN} types and conditions, \texttt{WITH}-clause based common table expressions (CTEs), and row-level locking modes such as \texttt{FOR UPDATE}.  
It also introduces extended functionalities such as \texttt{GROUP BY} with \texttt{HAVING} filters and \texttt{ORDER BY} clauses, nested function calls with type casting and \texttt{CASE} expressions.  
These extensions collectively allow our system to generate queries that better reflect the syntactic and semantic richness of real-world DBMS workloads.

A key difference between our design and \textsc{Pinolo} lies in the treatment of aggregation and grouping operations.  
\textsc{Pinolo} does not support \texttt{GROUP BY} or \texttt{HAVING} clauses, as aggregation and window functions disrupt the set-containment relation on which its approximation model relies.   
Specifically, once aggregation is introduced, the query output no longer preserves monotonic inclusion over tuples—adding or removing rows may alter the aggregated values in non-monotonic ways. 
By contrast, our approach introduces a new class of value-semantic approximation relations as discussed in Section \ref{sec: SQL Query Approximation}, that model how numerical and aggregated results change under local semantic perturbations. 

%\begin{figure}[t]
%	\scriptsize
%	\[
%	\begin{array}{rlcl}
%		\textit{Statement} & S & ::= & Q \mid Q~\texttt{FOR}~LM \mid \texttt{WITH}~WI~(\texttt{,}~WI)^*~Q~[\texttt{FOR}~LM] \\[2pt]
%		
%		\textit{Query} & Q & ::= & QC~[OB]~[L] \mid Q~SO~Q \\[2pt]
%		
%		\textit{SelectCore} & QC & ::= & \texttt{SELECT}~[\texttt{DISTINCT}]~SL~FC~[WH]~[GB] \\[2pt]
%		
%		\textit{SelectList} & SL & ::= & VE~[\texttt{AS}~id]~(\texttt{,}~VE~[\texttt{AS}~id])^* \\[2pt]
%		
%		\textit{FromClause} & FC & ::= & \texttt{FROM}~TR~(\texttt{,}~TR)^* \\[2pt]
%		
%		\textit{TableRef} & TR & ::= & TN~[\texttt{AS}~id] \mid (\;Q\;)~\texttt{AS}~id \mid JT \\[2pt]
%		
%		\textit{JoinedTable} & JT & ::= & TR~JTYP~\texttt{JOIN}~TR~[\texttt{ON}~BE] \\[2pt]
%		
%		\textit{JoinType} & JTYP & ::= & \texttt{INNER} \mid \texttt{LEFT OUTER} \mid \texttt{RIGHT OUTER} \mid \texttt{CROSS} \\[2pt]
%		
%		\textit{Where} & WH & ::= & \texttt{WHERE}~BE \\[2pt]
%		
%		\textit{GroupBy} & GB & ::= & \texttt{GROUP BY}~CR~(\texttt{,}~CR)^*~[\texttt{HAVING}~BE] \\[2pt]
%		
%		\textit{OrderBy} & OB & ::= & \texttt{ORDER BY}~OI~(\texttt{,}~OI)^* \\[2pt]
%		
%		\textit{OrderItem} & OI & ::= & VE~[\texttt{ASC}\mid\texttt{DESC}] \\[2pt]
%		
%		\textit{Limit} & L & ::= & \texttt{LIMIT}~int \\[2pt]
%		
%		\textit{SetOp} & SO & ::= & \texttt{UNION} \mid \texttt{UNION ALL} \mid \texttt{INTERSECT} \mid \texttt{EXCEPT} \\[2pt]
%		
%		\textit{BoolExpr} & BE & ::= & VE~COP~VE \mid \texttt{(}BE\texttt{)}~\texttt{AND}~\texttt{(}BE\texttt{)}
%		\\
%		& & \mid & \texttt{(}BE\texttt{)}~\texttt{OR}~\texttt{(}BE\texttt{)} \mid \texttt{NOT}~BE
%		\mid VE~\texttt{IS}~[\texttt{NOT}]~\texttt{NULL}
%		\\
%		& & \mid & \texttt{EXISTS}~(\;Q\;) \\[2pt]
%		
%		\textit{CompOp} & COP & ::= & \texttt{=} \mid \texttt{<>} \mid \texttt{<} \mid \texttt{>} \mid \texttt{<=} \mid \texttt{>=} \mid \texttt{LIKE} \mid \texttt{REGEXP} \mid \texttt{RLIKE} \mid \texttt{BETWEEN} \\[2pt]
%		
%		\textit{ValueExpr} & VE & ::= & FCALL \mid SUBSEL \mid CASE \mid CR \mid CONST \\[2pt]
%		
%		\textit{FuncCall} & FCALL & ::= & id~\texttt{(}~[ARG~(\texttt{,}~ARG)^*]~\texttt{)} \\[2pt]
%		
%		\textit{Arg} & ARG & ::= & VE \mid \texttt{CAST(}~VE~\texttt{AS}~TYP~\texttt{)} \\[2pt]
%		
%		\textit{AtomicSubselect} & SUBSEL & ::= & \texttt{(}~Q~\texttt{)} \\[2pt]
%		
%		\textit{CaseExpr} & CASE & ::= & \texttt{CASE}~\texttt{WHEN}~BE~\texttt{THEN}~VE~\texttt{ELSE}~VE~\texttt{END} \\[2pt]
%		
%		\textit{ColumnRef} & CR & ::= & id~[\texttt{.}~id] \\[2pt]
%		
%		\textit{Const} & CONST & ::= & int \mid str \mid num \mid \texttt{TRUE} \mid \texttt{FALSE} \mid \texttt{NULL} \\[2pt]
%		
%		\textit{LockMode} & LM & ::= & \texttt{UPDATE} \mid \texttt{SHARE} \mid \texttt{NO KEY UPDATE} \mid \texttt{KEY SHARE} \\[2pt]
%		
%		\textit{WithItem} & WI & ::= & id~\texttt{AS}~(\;Q\;) \\[2pt]
%		
%		\textit{TableName} & TN & ::= & id \\[2pt]
%		
%		\textit{TypeName} & TYP & ::= & id \\[2pt]
%		
%		\textit{Identifier} & id & ::= & \text{SQL identifier} \qquad
%		\textit{Literals: } int,~num,~str
%	\end{array}
%	\]
%	\caption{\textbf{Compact SQL syntax supported by the tool (BNF-style).}}
%	\label{fig:sql-bnf-compact}
%\end{figure}

\begin{figure}[t]
	\scriptsize
	\renewcommand{\arraystretch}{0.9}
	\[
	\begin{array}{rlcl}
		\textit{Statement} & S & ::= & 
		Q \mid Q~\texttt{FOR}~LM 
		\mid \texttt{WITH}~WI~(\texttt{,}~WI)^*~Q~[\texttt{FOR}~LM] \\[2pt]
		
		\textit{Query} & Q & ::= & 
		QC~[OB]~[L] 
		\mid Q~SO~Q \\[2pt]
		
		\textit{SelectCore} & QC & ::= &
		\texttt{SELECT}~[\texttt{DISTINCT}]~SL~FC~[WH]~[GB] \\[2pt]
		
		\textit{SelectList} & SL & ::= & 
		VE~[\texttt{AS}~id]~(\texttt{,}~VE~[\texttt{AS}~id])^* \\[2pt]
		
		\textit{FromClause} & FC & ::= & 
		\texttt{FROM}~TR~(\texttt{,}~TR)^* \\[2pt]
		
		\textit{TableRef} & TR & ::= & 
		id~[\texttt{AS}~id] 
		\mid (\;Q\;)~\texttt{AS}~id 
		\mid TR~JTYP~\texttt{JOIN}~TR~[\texttt{ON}~BE] \\[2pt]
		
		\textit{JoinType} & JTYP & ::= &
		\texttt{INNER} 
		\mid \texttt{LEFT OUTER} 
		\mid \texttt{RIGHT OUTER} 
		\mid \texttt{CROSS} \\[2pt]
		
		\textit{Where} & WH & ::= &
		\texttt{WHERE}~BE \\[2pt]
		
		\textit{GroupBy} & GB & ::= &
		\texttt{GROUP BY}~CR~(\texttt{,}~CR)^*~[\texttt{HAVING}~BE] \\[2pt]
		
		\textit{OrderBy} & OB & ::= &
		\texttt{ORDER BY}~VE~[\texttt{ASC}\mid\texttt{DESC}]~(\texttt{,}~VE~[\texttt{ASC}\mid\texttt{DESC}])^* \\[2pt]
		
		\textit{Limit} & L & ::= &
		\texttt{LIMIT}~int \\[2pt]
		
		\textit{SetOp} & SO & ::= &
		\texttt{UNION} 
		\mid \texttt{UNION ALL} 
		\mid \texttt{INTERSECT} 
		\mid \texttt{EXCEPT} \\[2pt]
		
		\textit{BoolExpr} & BE & ::= &
		VE~COP~VE 
		\mid \texttt{NOT}~BE 
		\mid BE~\texttt{AND}~BE 
		\mid BE~\texttt{OR}~BE 
		\\[2pt]
		& & \mid &
		\texttt{EXISTS}~(\;Q\;)
		\mid VE~\texttt{IS}~[\texttt{NOT}]~\texttt{NULL} \\[2pt]
		& & \mid &
		VE~[\texttt{NOT}]~\texttt{IN}~(\;Q\; \mid VE~(\texttt{,}~VE)^*\;) \\[2pt]


		
		\textit{CompOp} & COP & ::= &
		\texttt{=} 
		\mid \texttt{<>} 
		\mid \texttt{<} 
		\mid \texttt{>} 
		\mid \texttt{<=} 
		\mid \texttt{>=} 
		\mid \texttt{LIKE} 
		\mid \texttt{BETWEEN} \\[2pt]
		
		\textit{ValueExpr} & VE & ::= &
		\texttt{CASE}~\texttt{WHEN}~BE~\texttt{THEN}~VE~\texttt{ELSE}~VE~\texttt{END}
		\mid \texttt{(}~Q~\texttt{)} 
		\\[2pt]
		& & \mid &
		\mid id
		\mid FCALL
		\mid CONST \\[2pt]
		
		\textit{FuncCall} & FCALL & ::= &
		id~\texttt{(}~[VE~(\texttt{,}~VE)^*]~\texttt{)} \\[2pt]
		
		\textit{LockMode} & LM & ::= &
		\texttt{UPDATE} 
		\mid \texttt{SHARE} 
		\mid \texttt{NO KEY UPDATE} 
		\mid \texttt{KEY SHARE} \\[2pt]
		
		\textit{WithItem} & WI & ::= &
		id~\texttt{AS}~(\;Q\;) \\[2pt]
		
		\textit{ColumnRef} & CR & ::= &
		id~[\texttt{.}~id] \\[2pt]
		
		\textit{Const} & CONST & ::= &
		\text{integer, float, string, date, time, timestamp,} \\[2pt]
		& & & \text{binary, TRUE, FALSE, NULL} \\[2pt]
	\end{array}
	\]
	\vspace{-4mm}
	\caption{\textbf{Compact SQL syntax supported by our approach.}}
	\label{fig:sql-bnf-compact}
	\vspace{-2mm}
\end{figure}



\subsection{Approximate Mutators}
\label{subsec:Approximate Mutators}

\subsection{Approximation Propagation Analysis}
\label{subsec:Approximation Propagation Analysis}

In this section, we further develop an executable algorithm to determine how local semantic changes propagate through the SQL AST.
The main purpose of this algorithm is to formalize the top-down reasoning process introduced in Definition~\ref{def:approximation_propagation} into a systematic, bottom-up propagation procedure that connects local node mutations with their global semantic consequences at the query level.

% Step 1: Initilization
Algorithm~\ref{alg:approximation_propagation} presents the overall propagation process.  
Initially (Line~1–3), the algorithm receives the mutated node information $node\_info$ and the complete AST of the query.  
It first identifies the mutated node $n_{mut}$ and constructs its ancestor chain from the mutation site to the query root, represented as $\text{list}=[n_{mut},\ldots,n_{root}]$.  
This structure enables the algorithm to traverse each parent operator sequentially and reason about how the mutation propagates upward.
% Step 2: Local relation at mutation site
The algorithm then initializes the local semantic level of the mutation (Line~5–7):
if the mutated node involves predicates or subqueries, it starts at the set level ($\alpha(n_{mut})=s$); otherwise, for expressions or aggregations, it starts at the value level ($\alpha(n_{mut})=v$).
A direction accumulator $sign$ is also initialized to $+1$ to indicate that propagation initially preserves directionality.
% Step 3: Bottom-up propagation
In the propagation stage (Line~9–17), the algorithm iteratively traverses each parent node of $n_{mut}$ in a bottom-up manner. 
Before propagating, the algorithm invokes \textsc{DependsOn}$(n_i, n_{i-1})$ to check whether the parent node semantically depends on the mutated child node—by referencing its output column (for value-level nodes) or embedding it as a subquery or relation (for set-level nodes).   
Only dependent nodes are considered for propagation.  
For each parent operator $op_i$ (Line~9),  it consults Table~\ref{tab:op_type_rules} to retrieve the corresponding semantic mapping $(\alpha_{in} \rightarrow \alpha_{out})$ and its monotonic direction $\sigma(op_i)\in\{+1,-1\}$ (Line~13). 
The semantic level $\alpha$ is updated according to the operator’s input-output mapping (e.g., Set$\rightarrow$Value for aggregation or Value$\rightarrow$Set for predicate filters), while the cumulative direction $sign$ is updated multiplicatively ($sign \gets sign \cdot \sigma(op_i)$), preserving or reversing the relation based on operator polarity (Line~14–16).  
This recursive process effectively tracks the path of semantic transformation from the mutation site to the query output.
% Step 4: Materialize root-level relation
Finally, at the root node (Line~19–25), the algorithm derives the final query-level relation—returning either a set-level ($R(q_1,D)!\preceq^s_D!R(q_2,D)$) or value-level ($V_{q_1}(g,c)!\preceq^v_D!V_{q_2}(g,c)$) approximation, determined by the accumulated propagation direction.

%\begin{algorithm}[t]
%	\caption{Approximation Propagation across SQL AST}
%	\label{alg:approximation_propagation}
%	\footnotesize
%	\begin{algorithmic}[1]
%		\Require Mutated node info $node\_info$, SQL AST $AST$
%		\Ensure Final query-level approximation between original and mutated queries
%		
%		\State \textbf{ // Step 1: Initialization}
%		\State Identify mutated node $n_{mut}$.
%		\State Build ancestor chain $\text{list}=[n_{mut},\ldots,n_{root}]$.
%		
%		\State \textbf{ // Step 2: Local relation at mutation site}
%		\State Decide initial level $\alpha(n_{mut}) \in \{s,v\}$ by node type.
%		\State Set local relation $\mathcal{R}(n_{mut}) \gets (\preceq^{\alpha(n_{mut})})$.
%		\State Set direction accumulator $sign \gets +1$.
%		
%		\State \textbf{ // Step 3: Bottom-up propagation}
%		\For{each parent node $n_i$ in \textit{list} (from child to root)}
%		\State Determine operator type $op_i$ at $n_i$.
%		\State Lookup rule in Table~\ref{tab:op_type_rules} for $op_i$.
%		\State Obtain mapping $(\alpha_{in} \!\rightarrow\! \alpha_{out})$.
%		\State Obtain monotonic direction $\sigma(op_i)\!\in\!\{+1,-1\}$.
%		\State Update level: $\alpha(n_{i+1}) \gets \alpha_{out}$.
%		\State Update direction: $sign \gets sign \cdot \sigma(op_i)$.
%		\State Propagate symbolically: 
%		\Statex \hspace{1.7em} $\mathcal{R}(n_{i+1}) \gets \mathcal{R}(n_i)$ with $sign$ applied.
%		\EndFor
%		
%		\State \textbf{ // Step 4: Materialize root-level relation}
%		\If{$\alpha(n_{root}) = s$}
%		\State \textbf{return} $R(q_1,D) \preceq^{s}_{D} R(q_2,D)$ with sign $+$,
%		\Statex \hspace{2.95em} or $R(q_1,D) \succeq^{s}_{D} R(q_2,D)$ with sign $-$.
%		\Else
%		\State \textbf{return} $V_{q_1}(g,c) \preceq^{v}_{D} V_{q_2}(g,c)$ with sign $+$,
%		\Statex \hspace{2.95em} or $V_{q_1}(g,c) \succeq^{v}_{D} V_{q_2}(g,c)$ with sign $-$.
%		\EndIf
%	\end{algorithmic}
%\end{algorithm}


\begin{algorithm}[t]
	\caption{Approximation Propagation across SQL AST}
	\footnotesize
	\label{alg:approximation_propagation}
	\begin{algorithmic}[1]
		\Require Mutated node info $node\_info$, SQL AST $AST$
		\Ensure Final query-level approximation between original and mutated queries
		
		\State \textbf{// Step 1: Initialization}
		\State Identify mutated node $n_{mut}$.
		\State Build ancestor chain $\text{list} = [n_{mut}, \ldots, n_{root}]$.
		
		\State \textbf{// Step 2: Local relation at mutation site}
		\State Decide initial level $\alpha(n_{mut}) \in \{s, v\}$ by node type.
		\State Set local relation $\mathcal{R}(n_{mut}) \gets (\preceq^{\alpha(n_{mut})})$.
		\State Initialize direction accumulator $sign \gets +1$.
		
		\State \textbf{// Step 3: Bottom-up propagation}
		\For{each parent node $n_i$ in \textit{list} (from child to root)}
		\State Determine operator type $op_i$ at $n_i$.
		\If{\textbf{not} \textsc{DependsOn}$(n_i, n_{i-1})$} \textbf{continue} \EndIf
		\State Lookup rule of $op_i$ in Table~\ref{tab:op_type_rules} to get $(\alpha_{in}\!\rightarrow\!\alpha_{out}, \sigma(op_i))$.
		\State Update level: $\alpha(n_{i+1}) \gets \alpha_{out}$.
		\State Update direction: $sign \gets sign \cdot \sigma(op_i)$.
		\State Propagate symbolically: $\mathcal{R}(n_{i+1}) \gets \mathcal{R}(n_i)$ with $sign$ applied.
		\EndFor
		
		\State \textbf{// Step 4: Materialize root-level relation}
		\If{$\alpha(n_{root}) = s$}
		\State \textbf{return} $R(q_1,D) \preceq^{s}_{D} R(q_2,D)$ with sign $+$,
		\State \textbf{or} $R(q_1,D) \succeq^{s}_{D} R(q_2,D)$ with sign $-$.
		\Else
		\State \textbf{return} $V_{q_1}(g,c) \preceq^{v}_{D} V_{q_2}(g,c)$ with sign $+$,
		\State \textbf{or} $V_{q_1}(g,c) \succeq^{v}_{D} V_{q_2}(g,c)$ with sign $-$.
		\EndIf
%		\State \textbf{// Step 4: Materialize root-level relation}
%		\If{$\alpha(n_{root}) = s$}
%		\If{$sign = +1$}
%		\State \textbf{return} $q_1 \preceq_D^s q_2$ \hfill \textit{// set-level under-approximation}
%		\Else
%		\State \textbf{return} $q_1 \succeq_D^s q_2$ \hfill \textit{// set-level over-approximation}
%		\EndIf
%		\Else
%		\If{$sign = +1$}
%		\State \textbf{return} $q_1 \preceq_D^v q_2$ \hfill \textit{// value-level under-approximation}
%		\Else
%		\State \textbf{return} $q_1 \succeq_D^v q_2$ \hfill \textit{// value-level over-approximation}
%		\EndIf
%		\EndIf

		
		\vspace{1.5mm}
		% ---------- Numbered nested function ----------
		\Function{DependsOn}{parent, child}
		\If{$\alpha(child) = v$}
		\State \Return parent.exprs contains column or alias from child
		\ElsIf{$\alpha(child) = s$}
		\State \Return parent.references(child) as subquery or table
		\Else
		\State \Return \textbf{false}
		\EndIf
		\EndFunction
		% ---------------------------------------------
	\end{algorithmic}
\end{algorithm}

\begin{figure}[t]
	\centering
	\includegraphics[width=1\linewidth]{./images/propogation_example.pdf} 
	\vspace{-6mm}
	\caption{\textbf{Example of how the proposed algorithm propagates local semantic changes across the SQL AST.}}
	\label{fig:motivating-example}
%	\vspace{-5mm}
\end{figure}

As illustrated in Figure~\ref{fig:motivating-example}, the mutation occurs at the aggregation node where \texttt{MAX(c1)} is replaced by \texttt{MIN(c1)}, initializing a value-level relation ($\alpha=v$) with reversed monotonicity ($\sigma=-1$). 
Following Algorithm~\ref{alg:approximation_propagation}, the algorithm then traverses its ancestor chain $\text{list}=[n_{\text{MAX}}, n_{\text{subq}}, n_{\text{WHERE}}, n_{\text{COUNT}}]$ to evaluate how this local change propagates upward through the query structure. 
When the propagation reaches the subquery node (\texttt{SELECT ... AS x}), the semantics are lifted from the value level to the set level ($\alpha: v\!\rightarrow\!s$, $\sigma=+1$). 
According to Table~\ref{tab:op_type_rules}, a subquery appearing in the \texttt{FROM} clause acts as a data source that preserves tuple inclusion—expanding the underlying relation results in a superset of tuples, thus maintaining positive monotonicity. 
The subsequent \texttt{WHERE x>100} clause applies a filtering operator that preserves the set level but reverses direction ($\alpha: s\!\rightarrow\!s$, $\sigma=-1$). 
Finally, the outer \texttt{COUNT(*)} operator aggregates the resulting set back to a value-level ($\alpha: s\!\rightarrow\!v$, $\sigma=+1$). 
The cumulative sign is therefore $(-1)\!\times\!(+1)\!\times\!(-1)\!\times\!(+1)=+1$, yielding a final value-level approximation $V_{q_1}(g,c)\preceq^v_D V_{q_2}(g,c)$, which indicates that the output of $q_1$ forms a value-level under-approximation of $q_2$.

%\begin{table*}[t]
%	\centering
%	\scriptsize
%	\caption{\textbf{Operator Types and Semantic Propagation Rules}}
%	\vspace{-3mm}
%	\label{tab:op_type_rules}
%	\renewcommand{\arraystretch}{1.15}
%	\begin{tabular}{p{2.6cm} p{2.7cm} p{2.7cm} p{6.5cm}}
%		\toprule
%		\textbf{Operator Type} & \textbf{Semantic Mapping} & 
%		\textbf{Monotonic Direction $\sigma(op)$} & 
%		\textbf{Example and Interpretation} \\
%		\midrule
%		
%		\textbf{Aggregation Functions} &
%		Set $\rightarrow$ Value &
%		\begin{tabular}[c]{@{}l@{}}$+1$: MAX, SUM, COUNT\\$-1$: MIN\end{tabular} &
%		Maps an input set to a single value. Expanding the input set increases the output for MAX/SUM/COUNT or decreases it for MIN. \\
%		
%		\midrule
%		\textbf{Predicate / Filter} &
%		Value $\rightarrow$ Set &
%		\begin{tabular}[c]{@{}l@{}}$+1$: $x>c$, $x\ge c$\\$-1$: $x<c$, $x\le c$\end{tabular} &
%		Maps scalar values to tuple sets. Larger values make $x>c$ easier to satisfy (expanding the result set) but $x<c$ harder to satisfy (shrinking it). \\
%		
%		\midrule
%		\textbf{Logical Operator} &
%		Set $\rightarrow$ Set &
%		\begin{tabular}[c]{@{}l@{}}$+1$: EXISTS, OR\\$-1$: NOT, NOT EXISTS, AND\end{tabular} &
%		Negation or conjunction flips or restricts inclusion direction: 
%		\texttt{EXISTS}/\texttt{OR} enlarge results; 
%		\texttt{NOT}/\texttt{AND} shrink or invert inclusion. \\
%		
%		\midrule
%		\textbf{Arithmetic / Expression} &
%		Value $\rightarrow$ Value &
%		\begin{tabular}[c]{@{}l@{}}Depends on sign of constant\end{tabular} &
%		Linear expressions preserve or reverse direction: 
%		\texttt{x + k} ($+1$ if $k>0$), 
%		\texttt{x * k} ($+1$ if $k>0$, $-1$ if $k<0$), 
%		\texttt{-x} reverses monotonicity. \\
%		
%		\midrule
%		\textbf{Join / Projection / Subquery} &
%		Set $\rightarrow$ Set &
%		\begin{tabular}[c]{@{}l@{}}$+1$: JOIN, SELECT, UNION\\$-1$: INTERSECT, EXCEPT\end{tabular} &
%		Structural operators propagate tuple inclusion: 
%		\texttt{JOIN}, \texttt{UNION}, \texttt{SELECT} preserve inclusion ($+1$);
%		\texttt{INTERSECT} and \texttt{EXCEPT} restrict or invert it ($-1$). \\
%		
%		\bottomrule
%	\end{tabular}
%\end{table*}

\begin{table*}[t]
	\centering
	\scriptsize
	\caption{\textbf{Operator Types and Semantic Propagation Rules.}}
	\vspace{-2mm}
	\label{tab:op_type_rules}
	\renewcommand{\arraystretch}{1.3}
	\setlength{\extrarowheight}{1pt}
	\setlength{\tabcolsep}{5pt}
	
	% 每隔一行使用灰色底色
	\rowcolors{2}{rowgray}{white}
	
	\begin{tabular}{p{2.5cm} p{2.5cm} p{3.8cm} p{7.0cm}}
		\toprule
		\textbf{Operator Type} & \textbf{Semantic Mapping} &
		\textbf{Monotonic Direction $\sigma(op)$} &
		\textbf{Example and Interpretation} \\
		\midrule
		
		\textbf{Aggregation Functions} &
		Set $\rightarrow$ Value &
		\begin{tabular}[t]{@{}l@{}}$+1$: \texttt{MAX}, \texttt{SUM}, \texttt{COUNT}\\$-1$: \texttt{MIN}\end{tabular} &
		Expanding the input set increases the aggregated result for \texttt{MAX}/\texttt{SUM}/\texttt{COUNT}, or decreases it for \texttt{MIN}. \\[2pt]
		
		\textbf{Predicate / Filter} &
		Value $\rightarrow$ Set &
		\begin{tabular}[t]{@{}l@{}}$+1$: $x>c$, $x\ge c$\\$-1$: $x<c$, $x\le c$\end{tabular} &
		Increasing the compared value makes $x>c$ easier (result set expands) and $x<c$ harder (result set shrinks). \\[2pt]
		
		\textbf{Logical Operator} &
		Set $\rightarrow$ Set &
		\begin{tabular}[t]{@{}l@{}}$+1$: \texttt{EXISTS}, \texttt{OR}, \texttt{AND}\\$-1$: \texttt{NOT}, \texttt{NOT EXISTS}\end{tabular} &
		\texttt{OR}/\texttt{EXISTS}/\texttt{AND} are monotone increasing w.r.t.\ each input (union/exists/intersection);
		\texttt{NOT}/\texttt{NOT EXISTS} flip inclusion. \\[2pt]
		
		\textbf{Arithmetic / Expression} &
		Value $\rightarrow$ Value &
		Depends on operator sign &
		Linear arithmetic preserves or reverses direction:
		\texttt{x + k} ($+1$ if $k>0$),
		\texttt{x * k} ($+1$ if $k>0$, $-1$ if $k<0$),
		and \texttt{-x} flips monotonicity. \\[2pt]
		
		\textbf{Join / Projection / Set Op} &
		Set $\rightarrow$ Set &
		\begin{tabular}[t]{@{}l@{}}$+1$: \texttt{JOIN}, \texttt{SELECT}, \texttt{UNION}, \texttt{INTERSECT}\\
			mixed: \texttt{EXCEPT} (\textit{left} $+1$ / \textit{right} $-1$)\end{tabular} &
		Structural operators propagate tuple inclusion:
		\texttt{JOIN}, basic \texttt{SELECT}, \texttt{UNION}, \texttt{INTERSECT} are monotone increasing;
		\texttt{EXCEPT} increases with the left input but decreases with the right input. \\[2pt]
		
		\textbf{Subquery / CTE} &
		Context-dependent &
		\begin{tabular}[t]{@{}l@{}}$+1$: as \texttt{FROM}/CTE source\\inherits parent: scalar subquery\end{tabular} &
		Monotonicity depends on usage context: (1) In the \texttt{FROM} clause (e.g., \texttt{SELECT * FROM (SELECT a FROM t)}), it acts as a data source and preserves inclusion ($+1$). (2) As a scalar subquery (e.g., \texttt{WHERE x > (SELECT AVG(y) FROM t)}), it inherits the outer predicate’s direction (\texttt{>} $\Rightarrow +1$, \texttt{<} $\Rightarrow -1$). (3) For a CTE (e.g., \texttt{WITH cte AS (...) SELECT * FROM cte}), it behaves similarly to a \texttt{FROM} subquery, typically monotonic ($+1$). \\[2pt]
		
		\bottomrule
	\end{tabular}
\end{table*}



\subsection{Results Checking}
\label{subsec:Results Checking}

The primary purpose of results checking is to verify whether the outputs of the original and mutated SQL queries align with the predicted approximation relations, as defined in the previous section. 
Unlike traditional methods that rely on strict equivalence or set inclusion checks, which often miss subtle semantic differences, our approach incorporates both set-semantic and value-semantic approximation relations. 
This allows us to detect a wider range of logical inconsistencies in DBMS query results.
In our approach, after executing both queries, we compare their results based on the expected approximation relation (set or value). 
Specifically, for set-semantic approximation, we check if the result set of the mutated query is a subset or superset of the original query's result set, as predicted by the approximation relation. 
For value-semantic approximation, we compare the values in the target columns of both queries, ensuring that they satisfy the expected monotonic relationship (either increasing or decreasing).
A violation of this relation signals a logical inconsistency in the DBMS's query processing.


